"""Alert API endpoints."""

from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, Query, status
from sqlalchemy.orm import Session

from app.core.config import settings
from app.core.database import get_db
from app.core.dependencies import get_current_user
from app.models.user import User
from app.schemas.alert import (
    AlertResponse,
    AlertAcknowledge,
    AlertResolve,
    AlertSettingsResponse,
    AlertSettingsUpdate
)
from app.services.alert_service import AlertService


router = APIRouter(prefix="/alerts", tags=["alerts"])


def get_alert_service(db: Session = Depends(get_db)) -> AlertService:
    """Dependency to get AlertService instance."""
    return AlertService(db)


@router.get(
    "",
    response_model=List[AlertResponse],
    summary="List all alerts",
    description="Retrieve all alerts with optional filtering by status, type, and severity.",
    responses={
        200: {
            "description": "List of alerts retrieved successfully",
            "content": {
                "application/json": {
                    "example": [
                        {
                            "id": "123e4567-e89b-12d3-a456-426614174000",
                            "product_id": "123e4567-e89b-12d3-a456-426614174001",
                            "alert_type": "low_stock",
                            "severity": "critical",
                            "message": "Product stock is below reorder threshold",
                            "status": "active",
                            "created_at": "2024-01-15T10:30:00Z",
                            "acknowledged_at": None,
                            "resolved_at": None,
                            "product_name": "Widget A",
                            "product_sku": "WDG-001",
                            "current_stock": 5
                        }
                    ]
                }
            }
        },
        401: {"description": "Not authenticated"}
    }
)
async def list_alerts(
    status: Optional[str] = Query(None, description="Filter by status: active, acknowledged, resolved"),
    alert_type: Optional[str] = Query(None, description="Filter by type: low_stock, predicted_depletion"),
    severity: Optional[str] = Query(None, description="Filter by severity: warning, critical"),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum number of records to return"),
    current_user: User = Depends(get_current_user),
    alert_service: AlertService = Depends(get_alert_service)
) -> List[AlertResponse]:
    """
    Retrieve all alerts with optional filtering.
    
    This endpoint returns inventory alerts generated by the system, including
    low stock warnings and predicted depletion alerts from ML forecasting.
    
    **Query Parameters:**
    - **status**: Filter by alert status
      - `active`: Alerts that need attention
      - `acknowledged`: Alerts that have been seen but not resolved
      - `resolved`: Alerts that have been addressed
    - **alert_type**: Filter by alert type
      - `low_stock`: Stock level below reorder threshold
      - `predicted_depletion`: ML prediction indicates stock will run out soon
    - **severity**: Filter by severity level
      - `warning`: Non-critical alerts (stock getting low)
      - `critical`: Urgent alerts (stock critically low or imminent depletion)
    - **skip**: Number of records to skip (for pagination, default: 0)
    - **limit**: Maximum number of records to return (1-1000, default: 100)
    
    **Returns:**
    - List of alerts with product information
    - Alert details (type, severity, message, timestamps)
    - Current stock level for context
    
    **Use Cases:**
    - Dashboard alert notifications
    - Monitoring inventory health
    - Prioritizing restocking actions
    - Alert management and workflow
    """
    alerts = alert_service.get_all_alerts(
        status=status,
        alert_type=alert_type,
        severity=severity,
        skip=skip,
        limit=limit
    )
    
    # Convert to response models with product information
    response_alerts = []
    for alert in alerts:
        alert_dict = {
            "id": alert.id,
            "product_id": alert.product_id,
            "alert_type": alert.alert_type,
            "severity": alert.severity,
            "message": alert.message,
            "status": alert.status,
            "created_at": alert.created_at,
            "acknowledged_at": alert.acknowledged_at,
            "resolved_at": alert.resolved_at,
            "product_name": alert.product.name if alert.product else None,
            "product_sku": alert.product.sku if alert.product else None,
            "current_stock": alert.product.current_stock if alert.product else None,
        }
        response_alerts.append(AlertResponse(**alert_dict))
    
    return response_alerts


@router.post(
    "/{alert_id}/acknowledge",
    response_model=AlertResponse,
    summary="Acknowledge an alert",
    description="Mark an alert as acknowledged to indicate it has been seen.",
    responses={
        200: {
            "description": "Alert acknowledged successfully",
            "content": {
                "application/json": {
                    "example": {
                        "id": "123e4567-e89b-12d3-a456-426614174000",
                        "product_id": "123e4567-e89b-12d3-a456-426614174001",
                        "alert_type": "low_stock",
                        "severity": "critical",
                        "message": "Product stock is below reorder threshold",
                        "status": "acknowledged",
                        "created_at": "2024-01-15T10:30:00Z",
                        "acknowledged_at": "2024-01-15T11:00:00Z",
                        "resolved_at": None,
                        "product_name": "Widget A",
                        "product_sku": "WDG-001",
                        "current_stock": 5
                    }
                }
            }
        },
        401: {"description": "Not authenticated"},
        404: {"description": "Alert not found"}
    }
)
async def acknowledge_alert(
    alert_id: UUID,
    current_user: User = Depends(get_current_user),
    alert_service: AlertService = Depends(get_alert_service)
) -> AlertResponse:
    """
    Acknowledge an alert to indicate it has been seen.
    
    Acknowledging an alert changes its status from 'active' to 'acknowledged'
    and records the timestamp. This helps track which alerts have been reviewed
    without marking them as fully resolved.
    
    **Path Parameters:**
    - **alert_id**: UUID of the alert to acknowledge
    
    **Status Transition:**
    - Before: `active`
    - After: `acknowledged`
    - Sets: `acknowledged_at` timestamp
    
    **Returns:**
    - Updated alert with new status and timestamp
    - Complete product information for context
    
    **Use Cases:**
    - Mark alerts as "seen" in dashboard
    - Track alert response times
    - Workflow management (acknowledged but not yet resolved)
    - Team coordination (show which alerts are being handled)
    """
    alert = alert_service.acknowledge_alert(alert_id)
    
    # Convert to response model with product information
    alert_dict = {
        "id": alert.id,
        "product_id": alert.product_id,
        "alert_type": alert.alert_type,
        "severity": alert.severity,
        "message": alert.message,
        "status": alert.status,
        "created_at": alert.created_at,
        "acknowledged_at": alert.acknowledged_at,
        "resolved_at": alert.resolved_at,
        "product_name": alert.product.name if alert.product else None,
        "product_sku": alert.product.sku if alert.product else None,
        "current_stock": alert.product.current_stock if alert.product else None,
    }
    
    return AlertResponse(**alert_dict)


@router.post(
    "/{alert_id}/resolve",
    response_model=AlertResponse,
    summary="Resolve an alert",
    description="Mark an alert as resolved after addressing the underlying issue.",
    responses={
        200: {
            "description": "Alert resolved successfully",
            "content": {
                "application/json": {
                    "example": {
                        "id": "123e4567-e89b-12d3-a456-426614174000",
                        "product_id": "123e4567-e89b-12d3-a456-426614174001",
                        "alert_type": "low_stock",
                        "severity": "critical",
                        "message": "Product stock is below reorder threshold",
                        "status": "resolved",
                        "created_at": "2024-01-15T10:30:00Z",
                        "acknowledged_at": "2024-01-15T11:00:00Z",
                        "resolved_at": "2024-01-15T14:30:00Z",
                        "product_name": "Widget A",
                        "product_sku": "WDG-001",
                        "current_stock": 150
                    }
                }
            }
        },
        401: {"description": "Not authenticated"},
        404: {"description": "Alert not found"}
    }
)
async def resolve_alert(
    alert_id: UUID,
    current_user: User = Depends(get_current_user),
    alert_service: AlertService = Depends(get_alert_service)
) -> AlertResponse:
    """
    Resolve an alert after addressing the underlying issue.
    
    Resolving an alert marks it as complete and removes it from active
    alert lists. Use this after restocking products or addressing the
    condition that triggered the alert.
    
    **Path Parameters:**
    - **alert_id**: UUID of the alert to resolve
    
    **Status Transition:**
    - Before: `active` or `acknowledged`
    - After: `resolved`
    - Sets: `resolved_at` timestamp
    
    **Returns:**
    - Updated alert with resolved status and timestamp
    - Complete product information showing current state
    
    **Use Cases:**
    - Mark alerts as complete after restocking
    - Close alerts after addressing inventory issues
    - Track alert resolution times and patterns
    - Clean up alert dashboard after taking action
    
    **Best Practice:**
    - Resolve alerts only after the underlying issue is fixed
    - For low_stock alerts: resolve after restocking
    - For predicted_depletion alerts: resolve after adjusting inventory or consumption
    """
    alert = alert_service.resolve_alert(alert_id)
    
    # Convert to response model with product information
    alert_dict = {
        "id": alert.id,
        "product_id": alert.product_id,
        "alert_type": alert.alert_type,
        "severity": alert.severity,
        "message": alert.message,
        "status": alert.status,
        "created_at": alert.created_at,
        "acknowledged_at": alert.acknowledged_at,
        "resolved_at": alert.resolved_at,
        "product_name": alert.product.name if alert.product else None,
        "product_sku": alert.product.sku if alert.product else None,
        "current_stock": alert.product.current_stock if alert.product else None,
    }
    
    return AlertResponse(**alert_dict)


@router.get("/settings", response_model=AlertSettingsResponse)
async def get_alert_settings(
    current_user: User = Depends(get_current_user)
) -> AlertSettingsResponse:
    """
    Get current alert settings.
    
    Returns the configuration for alert generation including:
    - Alert threshold days (days before predicted depletion to trigger alert)
    - Low stock alerts enabled/disabled
    - Predicted depletion alerts enabled/disabled
    - Email notifications enabled/disabled
    - Alert recipient email addresses
    """
    return AlertSettingsResponse(
        alert_threshold_days=settings.alert_threshold_days,
        low_stock_enabled=True,  # These could be stored in database in future
        predicted_depletion_enabled=True,
        email_notifications_enabled=settings.email_notifications_enabled,
        alert_recipient_emails=settings.alert_recipient_emails
    )


@router.put("/settings", response_model=AlertSettingsResponse)
async def update_alert_settings(
    settings_update: AlertSettingsUpdate,
    current_user: User = Depends(get_current_user)
) -> AlertSettingsResponse:
    """
    Update alert settings.
    
    Note: In this implementation, settings are stored in environment variables.
    This endpoint returns the current settings. In a production system,
    these settings would be stored in the database per user or organization.
    
    - **alert_threshold_days**: Days before predicted depletion to trigger alert (1-90)
    - **low_stock_enabled**: Enable or disable low stock alerts
    - **predicted_depletion_enabled**: Enable or disable predicted depletion alerts
    - **email_notifications_enabled**: Enable or disable email notifications for alerts
    - **alert_recipient_emails**: List of email addresses to receive alert notifications
    """
    # In a production system, you would update settings in the database here
    # For now, we just return the current settings from config
    
    # If alert_threshold_days is provided, update the settings object
    # Note: This will only persist for the current session
    if settings_update.alert_threshold_days is not None:
        settings.alert_threshold_days = settings_update.alert_threshold_days
    
    if settings_update.email_notifications_enabled is not None:
        settings.email_notifications_enabled = settings_update.email_notifications_enabled
    
    if settings_update.alert_recipient_emails is not None:
        settings.alert_recipient_emails = settings_update.alert_recipient_emails
    
    return AlertSettingsResponse(
        alert_threshold_days=settings.alert_threshold_days,
        low_stock_enabled=settings_update.low_stock_enabled if settings_update.low_stock_enabled is not None else True,
        predicted_depletion_enabled=settings_update.predicted_depletion_enabled if settings_update.predicted_depletion_enabled is not None else True,
        email_notifications_enabled=settings.email_notifications_enabled,
        alert_recipient_emails=settings.alert_recipient_emails
    )
